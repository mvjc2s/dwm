From 23fe20a42f5f889a8828539fd7549a0590cb3fb7 Mon Sep 17 00:00:00 2001
From: Marcus Vinicius Salvador dos Santos <marcus.v.salvador92@protonmail.com>
Date: Wed, 5 Nov 2025 19:47:07 -0300
Subject: [PATCH] patch 31: keychord-timeout [PATCH] Extend dwm-keychord
 functionality implementing a timeout function and uses XCheckMaskEvent
 instead of XNextEvent

---
 dwm-keychord-timeout-6.6.diff | 165 ++++++++++++++++++++++++++++++++++
 dwm.c                         | 126 ++++++++++++++++----------
 2 files changed, 243 insertions(+), 48 deletions(-)
 create mode 100644 dwm-keychord-timeout-6.6.diff

diff --git a/dwm.c b/dwm.c
index c04faa2..7e649ea 100644
--- a/dwm.c
+++ b/dwm.c
@@ -139,10 +139,10 @@ typedef struct {
 } Key;
 
 typedef struct {
-    unsigned int n;
-    const Key keys[5];
-	void (*func)(const Arg *);
-	const Arg arg;
+  unsigned int n;             // how much keys in keychord
+  const Key keys[5];          // keys arrays (maximum: 5)
+	void (*func)(const Arg *);  // function to execute
+	const Arg arg;              // function argument
 } Keychord;
 
 typedef struct {
@@ -233,6 +233,7 @@ static int gettextprop(Window w, Atom atom, char *text, unsigned int size);
 static void grabbuttons(Client *c, int focused);
 static void grabkeys(void);
 static void incnmaster(const Arg *arg);
+static void keychord_reset(void);
 static void keypress(XEvent *e);
 static void killthis(Client *c);
 static void killclient(const Arg *arg);
@@ -357,7 +358,7 @@ static Display *dpy;
 static Drw *drw;
 static Monitor *mons, *selmon;
 static Window root, wmcheckwin;
-unsigned int currentkey = 0;
+unsigned int currentkey = 0;  // what keychord we are in
 
 static xcb_connection_t *xcon;
 
@@ -685,6 +686,8 @@ checkotherwm(void)
 void
 cleanup(void)
 {
+  keychord_reset();
+
 	Arg a = {.ui = ~0};
 	Layout foo = { "", NULL };
 	Monitor *m;
@@ -1471,11 +1474,12 @@ grabkeys(void)
 				if (keychords[i]->keys[currentkey].keysym == syms[(k - start) * skip])
 					for (c = 0; c < LENGTH(modifiers); c++)
 						XGrabKey(dpy, k,
-							 keychords[i]->keys[currentkey].mod | modifiers[c],
+               keychords[i]->keys[currentkey].mod | modifiers[c],
 							 root, True,
 							 GrabModeAsync, GrabModeAsync);
-                if(currentkey > 0)
-                        XGrabKey(dpy, XKeysymToKeycode(dpy, XK_Escape), AnyModifier, root, True, GrabModeAsync, GrabModeAsync);
+    if(currentkey > 0)
+      XGrabKey(dpy, XKeysymToKeycode(dpy, XK_Escape), AnyModifier, root, True, GrabModeAsync, GrabModeAsync);
+
 		XFree(syms);
 	}
 }
@@ -1499,54 +1503,79 @@ isuniquegeom(XineramaScreenInfo *unique, size_t n, XineramaScreenInfo *info)
 }
 #endif /* XINERAMA */
 
+void
+keychord_reset(void)
+{
+    currentkey = 0;
+    grabkeys();
+}
+
 void
 keypress(XEvent *e)
 {
-	/* unsigned int i; */
-    XEvent event = *e;
-    unsigned int ran = 0;
+  XEvent event = *e;
+  unsigned int ran = 0;  // Flag: exucuted any function?
 	KeySym keysym;
 	XKeyEvent *ev;
 
-    Keychord *arr1[sizeof(keychords) / sizeof(Keychord*)];
-    Keychord *arr2[sizeof(keychords) / sizeof(Keychord*)];
-    memcpy(arr1, keychords, sizeof(keychords));
-    Keychord **rpointer = arr1;
-    Keychord **wpointer = arr2;
-
-    size_t r = sizeof(keychords)/ sizeof(Keychord*);
-
-    while(1){
-            ev = &event.xkey;
-            keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
-            size_t w = 0;
-            for (int i = 0; i < r; i++){
-                    if(keysym == (*(rpointer + i))->keys[currentkey].keysym
-                       && CLEANMASK((*(rpointer + i))->keys[currentkey].mod) == CLEANMASK(ev->state)
-                       && (*(rpointer + i))->func){
-                            if((*(rpointer + i))->n == currentkey +1){
-                                    (*(rpointer + i))->func(&((*(rpointer + i))->arg));
-                                    ran = 1;
-                            }else{
-                                    *(wpointer + w) = *(rpointer + i);
-                                    w++;
-                            }
-                    }
-            }
-            currentkey++;
-            if(w == 0 || ran == 1)
-                    break;
-            grabkeys();
-            while (running && !XNextEvent(dpy, &event) && !ran)
-                    if(event.type == KeyPress)
-                            break;
-            r = w;
-            Keychord **holder = rpointer;
-            rpointer = wpointer;
-            wpointer = holder;
+  Keychord *arr1[sizeof(keychords) / sizeof(Keychord*)];
+  Keychord *arr2[sizeof(keychords) / sizeof(Keychord*)];
+  memcpy(arr1, keychords, sizeof(keychords)); // copy read array to the memory
+  Keychord **rpointer = arr1;  // Read pointer: point to read array
+  Keychord **wpointer = arr2;  // Write pointer: point to write array
+
+  size_t r = sizeof(keychords) / sizeof(Keychord*); // how much keychords are being readed
+
+  while(1) {
+    ev = &event.xkey;
+    keysym = XKeycodeToKeysym(dpy, (KeyCode)ev->keycode, 0);
+
+    size_t w = 0; // how much keychords will be writed (matches)
+    for (int i = 0; i < r; i++) {
+      if(keysym == (*(rpointer + i))->keys[currentkey].keysym // is it a valid expected key?
+       && CLEANMASK((*(rpointer + i))->keys[currentkey].mod) == CLEANMASK(ev->state)  // ModKey
+       && (*(rpointer + i))->func) {  // any valid function?
+        if((*(rpointer + i))->n == currentkey + 1) {  // is it the last keychord key?
+          (*(rpointer + i))->func(&((*(rpointer + i))->arg)); // execute the keychord function
+          ran = 1;  // set ran variable to true, which means that function as been ran 
+        } else {
+          *(wpointer + w) = *(rpointer + i);  // copy the keychord to the read array
+          w++;  // increment the matches count
+        }
+      }
     }
-    currentkey = 0;
+
+    currentkey++;
+
+    if(w == 0 || ran == 1) break;
+
     grabkeys();
+
+    // Timeout: wait for the next key in 2 seconds
+    int timeout = 0;
+    while (running && timeout < 20) {
+      if (XCheckMaskEvent(dpy, KeyPressMask, &event)) {
+        if (event.type == KeyPress) break;
+      }
+
+      usleep(100000);  /* 100ms */
+      timeout++;
+    }
+
+    // If timeout, reset and leave
+    if (timeout >= 100) {
+        keychord_reset();
+        return;
+    }
+
+    r = w;
+    Keychord **holder = rpointer;
+    rpointer = wpointer;
+    wpointer = holder;
+  }
+
+  currentkey = 0;
+  grabkeys();
 }
 
 void
@@ -1924,6 +1953,7 @@ pushstack(const Arg *arg) {
 void
 quit(const Arg *arg)
 {
+  keychord_reset();
 	if(arg->i) restart = 1;
 	running = 0;
 }
-- 
2.51.2

